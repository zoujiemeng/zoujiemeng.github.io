---
layout: post
title: "MIT 6.00.1x 计算机科学和PYTHON编程导论 课程笔记"
tagline: ""
description: "MIT 6.00.1x 计算机科学和PYTHON编程导论 课程笔记"
category: python
tags: [python,tips]
last_updated: 2018-06-21
---

本文是在线课程`MIT 6.00.1X 计算机科学和PYTHON编程导论`的学习笔记，主要用来记录一些易忽略以及重要的知识点，文章按照课程顺序记录。

## 第二讲-编程基础
### 编程语言的分类
+ 编译型编程语言(compiled language):C/C++ Java
+ 解释型编程语言(interpreted language):Python
### Python scalar objects
+ int, e.g., 314 or 270
+ float, e.g., 3.14 or 27.0
+ bool: True or False
The built in Python function `type(object)` returns the type of an object
type conversion: `typename(object)`
### Python的操作运算符
+ 基本运算与比较符号与C/C++一致，乘方使用 `i**j`
+ 逻辑运算符较编译型语言直白，且增加了成员运算符和身份运算符，具体内容可参考http://www.runoob.com/python/python-operators.html#ysf4

## 第九讲-算法复杂度
第三讲至第八讲为Python基础知识，可参考上面提到的总结文章，需要特别注意的一点是list的引用和copy在代码写法上的区别。
+ $$O(1)$$ denotes constant running time，实际情况中，部分代码片段可能具有此性能，但实际上整体算法很罕见。
+ $$O(log n)$$ denotes logarithmic running time，以二分查找类算法
+ $$O(n)$$ denotes linear running time，最常见的就是顺序查找类算法
+ $$O(n log n)$$ denotes linear-logarithmic running time，最常见的就是常用的排序算法：归并排序
+ $$O(n^{c})$$ denotes poly running time，最常见的就是一些简单的排序算法如冒泡排序
+ $$O(c^{n})$$ denotes exponential running time，最常见的是一些复数递归的算法

## 第十讲-内存和查找
### 先排序后查找 > 顺序查找 ？
+ 对于单次的查找来说，先排序后查找的复杂度为$$O(n log n) + O(log n)$$，这里使用归并排序+二分查找，而直接顺序查找的复杂度为$$O(n)$$，显然前者 < 后者，不如直接用顺序查找的方式
+ 然而对于K次的查找来说，先排序后查找的复杂度为$$O(n log n) + K * O(log n)$$，而直接顺序查找的复杂度为$$K * O(n)$$，此时可以看出，当K的规模达到一定程度时，明显前者要好于后者，而实际应用时，正是这种情况：针对一个重要的数据库，我们可能执行上百万次甚至更多的查找。

### Hash查找
对于使用键值对结构组成的数据库，可以使用hash函数将每一个key映射到一个较小的整数集空间里面，这样通过hash值可以反求key，如果是一一对应的关系的话，就能在O(1)的复杂度下完成查找，然而当数据库足够大时，会不可避免的产生collision，因此评价一个Hash函数的标准就是在限定的子集空间内最大程度上避免collision的产生。

## 第十一讲-类
+ __init__ 方法复写初始化函数
+ __str__ 方法复写print函数

## 第十二讲-面向对象编程
+ list.sort()函数里面有一个lessthan参数，可以在类里面通过复写`obj1.__lt__(obj2)`函数实现
+ 超类的方法必须适用于所有子类，反过来不需要成立
+ 返回list的时候推荐返回其copy(变量名后面加[:])而不是其引用
+ GENERATORS:def 语句中含有yield的称为generators，一般在循环中使用，可避免循环次数过多时效率低的问题

## 第十三讲-树
+ DFS用栈实现，BFS用队列实现
+ 决策树可用递归的方式建立，可用BFS和DFS的方法搜索，一般来说，由于决策树只有leaf上是最终决策的原因，DFS的搜索更快
+ 隐式搜索的是递归实现，边搜索边建立决策树，可提升时间和空间上的效率
+ 如果放开树的定义限制，会出现类似节点的子节点是其祖先的情况，在这类情况下，DFS和BFS不在适用，需增加一个visit数组来标记已访问节点，而这类数据结构有一个更通用的称呼————图

## 总结
+ 有的时候问题可能会非常复杂（固有复杂度，无法通过算法优化）除非你愿意适用近似的方法，这是很重要的思想